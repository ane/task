<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Execution Model</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="css/kingfisher.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700|Source+Code+Pro" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Task</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="02-guide.html"><div class="inner"><span>User Guide</span></div></a></li><li class="depth-1  current"><a href="03-executors.html"><div class="inner"><span>Execution Model</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="task.core.html"><div class="inner"><span>task.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#execution-model" name="execution-model"></a>Execution Model</h1>
<p>In the task model, the execution model is intentionally kept opaque, but not hidden. This means that by default, the user doesn’t need to worry about where – in which thread – code is executed. </p>
<p>What the user needs to know, to <em>get started</em>, is:</p>
<ul>
  <li>all code is asynchronous and non-blocking, and</li>
  <li><code>deref</code> or <code>@</code> will block the <em>current thread</em>.</li>
</ul>
<p>The concurrency model is left to the <em>executor</em>.</p>
<p>A JVM executor is an abstraction for thread execution. This can be a thread pool with 64 threads per core. Or more. Or less. By default, task uses <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a>, a work-stealing scheduler, that attempts to find the best use for each of its threads.</p>
<p>The reason to default to the ForkJoinPool, in addition for it being perfomant, is that it kind of makes tasks appear lightweight (a bit like, but not similar to, fibers), as the user does not intentionally think that there is a one-to-one correspondence between each task and a thread. This means that you can have several hundred tasks executing concurrently for only a handful of threads! The ForkJoinPool handles the heavy lifting here: some tasks will complete faster, some slower, so the point is to have this work-stealing algorithm that makes use of idle threads.</p>
<p>It is often the case that such behavior is not desirable. Which is why the executor can be overridden via two methods:</p>
<ul>
  <li>implicitly by using dynamic binding, or</li>
  <li>explicitly by using parameters to task-executing functions.</li>
</ul>
<p>Dynamic binding is a standard Clojure method for doing dynamic scope. This is how it works.</p>
<pre><code class="clojure">(def ^:dynamic foo "hello")

(println foo) ; prints "hello"

(binding [foo "hi"]
  (println foo)) ; prints "ho"
</code></pre>
<p>Using this technique lets us freely swap the executor. The var for this is <a href="task.core.html#var-*pool*">*pool*</a>.</p>
<pre><code class="clojure">TODO: example
</code></pre>
<p>The JVM offers <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">several</a> you can freely chose from. This document is not a guide on their details, the user is left to explore that page or the Internet for more examples. </p>
<p>Usually, in 99% of cases, the default <code>ForkJoinPool</code> executor is just fine. But the option to customize is there.</p>
<h2><a href="#blocking-pitfalls" name="blocking-pitfalls"></a>Blocking pitfalls</h2>
<p>To get the value out of a task, you deref it. This blocks the executing thread. It is generally safe to do so, but choosing the wrong kind of executor might yield strange behaviour.</p>
<p>For example, when using a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool-int-">fixed thread pool</a> like this, it might not be obvious that once you run out of threads, the whole program will grind to a halt.</p>
<p>This is particularly nasty if you do it inside a HTTP server, e.g. you use the same thread pool for handling incoming web requests and database access. If your database hangs and takes time to answer the questions, the web server, which shares the thread pool, cannot spawn new threads to handle incoming requests and the web server will appear unresponsive!</p></div></div></div></body></html>
<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" type="text/css" href="css/kingfisher.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700|Source+Code+Pro" /></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Task</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1  current"><a href="02-guide.html"><div class="inner"><span>User Guide</span></div></a></li><li class="depth-1 "><a href="03-executors.html"><div class="inner"><span>Execution Model</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="task.core.html"><div class="inner"><span>task.core</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" name="user-guide"></a>User Guide</h1>
<p>This is the official Task user guide.</p>
<h2><a href="#creating-tasks" name="creating-tasks"></a>Creating tasks</h2>
<p>To create a task, use <a href="task.core.html#var-run">run</a>. It is a macro that evaluates its result in another thread. The execution is done in the <code>ForkJoinPool.commonPool()</code>:</p>
<pre><code class="clojure">(task/run (println "hello")
          (Thread/sleep 1000)
          123)
</code></pre>
<p>To get the value of the task, use <code>deref</code> or <code>@</code> from the Clojure standard library. This blocks the current thread.</p>
<pre><code class="clojure">; these are all equal
@(task/run 123) ; =&gt; 123

(deref (task/run 123))
</code></pre>
<p><em>See the docs on <a href="http://clojuredocs.org/clojure.core/deref">deref</a>.</em></p>
<p>Note, that calling <code>(run 123)</code> results possibly in the creation of another thread. To create an “immeadiate” value that doesn’t cause any unwanted execution, use <code>now</code>:</p>
<pre><code class="clojure">@(task/now 123)
</code></pre>
<p>To create an empty task you can use <code>(void)</code> which is a task that never completes.</p>
<p>If you want to use another executor, use <code>run-in</code>:</p>
<pre><code class="clojure">(let [pool (Executors/newFixedThreadPool 16)]
  (task/run-in pool
    (Thread/sleep 1000)
    123)
</code></pre>
<h2><a href="#composing-tasks" name="composing-tasks"></a>Composing tasks</h2>
<h3><a href="#function-application-" name="function-application-"></a>Function application: <code>then</code></h3>
<p>If you want to apply a function on the value returned by a task, use <code>then</code>:</p>
<pre><code class="clojure">(task/then clojure.string/upper-case (task/run "asdf"))
; =&gt; ASDF
</code></pre>
<p><code>then</code> produces another task, so you can deref its result:</p>
<pre><code class="clojure">@(task/then inc (task/run 123))

; =&gt; 124
</code></pre>
<p>If you want to apply a function that produces another task, use <code>compose</code>:</p>
<pre><code class="clojure">@(task/compose (fn [x] (task/run
                         (Thread/sleep 1212)
                         (inc x)))
               (task/run 778))
</code></pre>
<p>If you had used <code>then</code> the result would have been a task inside another task.</p>
<h2><a href="#interoperability" name="interoperability"></a>Interoperability</h2>
<p>Standard Clojure <code>future</code> and <code>promise</code> are compatible with tasks:</p>
<pre><code class="clojure">@(then inc (future 9)) ; =&gt; 10

(def foo (promise))

(then println foo)

(deliver foo "hello")

; prints "hello"
</code></pre>
<h2><a href="#using-executors" name="using-executors"></a>Using executors</h2>
<p>Both <code>then</code> and <code>compose</code> accept a third parameter as the <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>:</p>
<pre><code class="clojure">(let [pool (Executors/newFixedThreadPool 4)]
  (task/then inc (task/run 123) pool))
</code></pre>
<h2><a href="#using-to-avoid-boilerplate" name="using-to-avoid-boilerplate"></a>Using <code>for</code> to avoid boilerplate</h2>
<p>The <a href="task.core.html#var-for">for</a> macro, like its standard library namesake, lets you skip some boilerplate when working with tasks that depend on each other:</p>
<pre><code class="clojure">(task/for [x (task/run 123)
           y (future 123)
           z (task/run (Thread/sleep 1000) 4)]
  (+ x y z))
</code></pre>
<p><code>for</code> evaluates its body once all futures are complete, and the values of each future are bound to their respective bindings.</p>
<h1><a href="#lists-of-tasks" name="lists-of-tasks"></a>Lists of tasks</h1>
<p>If you have a sequence of tasks, and you want to deal with each result as a whole, you can turn a sequence of tasks into a task that evaluates into the values of each task inside it using <a href="task.core.html#var-sequence">sequence</a>:</p>
<pre><code class="clojure">@(task/sequence [(task/run 123) (future 9) (task/run (Thread/sleep 100) "hello")])

; =&gt; [123 9 "hello"]
</code></pre>
<p><code>sequence</code> completes when all the tasks complete.</p>
<h3><a href="#completion" name="completion"></a>Completion</h3>
<p>To check if a task is complete, use <a href="task.core.html#var-done.3F">done?</a>:</p>
<pre><code class="clojure">(task/done? some-task)

(task/done? (task/run (Thread/sleep 123123) 'foo))
; =&gt; false

(task/done? (task/now 1))
</code></pre>
<p>To complete a task before it is done, use <a href="task.core.html#var-complete.21">complete!</a>:</p>
<pre><code class="clojure">(def baz (task/run (Thread/sleep 10000) 'foo))

(task/complete! baz 'bar)

@baz ; =&gt; 'bar
</code></pre>
<p>If the task is already complete, it does nothing.</p>
<p>To get a value anyway if the task isn’t complete, use <a href="task.core.html#var-else">else</a>:</p>
<pre><code class="clojure">(else (task/run (Thread/sleep 1000) 1) 2)

; =&gt; 2
</code></pre>
<h1><a href="#forcing-a-result" name="forcing-a-result"></a>Forcing a result</h1>
<p>To force the result of a task, completed or not, use <a href="task.core.html#var-force.21">force!</a>:</p>
<pre><code class="clojure">(def t (task/now 123))

(task/force! t 'hi)

@t ; =&gt; 'hi
</code></pre>
<h3><a href="#cancellation" name="cancellation"></a>Cancellation</h3>
<p>To cancel a task, use <a href="task.core.html#var-cancel">cancel</a>:</p>
<pre><code class="clojure">(def my-task (task/run (Thread/sleep 10000) 'bla))

(task/cancel my-task)
</code></pre>
<p>To see if the task was cancelled, use <a href="task.core.html#var-cancelled.3F">cancelled?</a>:</p>
<pre><code class="clojure">(cancelled? my-task) ; =&gt; true
</code></pre>
<p>Using <code>deref</code> on a cancelled task blows up, predictably.</p>
<h3><a href="#failures" name="failures"></a>Failures</h3>
<p>A task is said to have <em>failed</em> if its evaluation produced an exception or it produced an exception during its execution. Such a task is a cancelled task (see <a href="#Cancellation">Cancellation</a>), or any task that produces an exception when <code>deref</code>’d:</p>
<pre><code class="clojure">(def oops (task/run (throw (RuntimeException. "hey!"))))

@oops

; RuntimeException hey!  task.core/fn--17494 (form-init7142405608168193525.clj:182)
</code></pre>
<p><a href="null">failed? </a>will tell you if that task has failed:</p>
<pre><code class="clojure">(task/failed? oops) ; =&gt; true
</code></pre>
<p>To create a failed task with some exception, use <a href="task.core.html#var-failed">failed</a>:</p>
<pre><code class="clojure">(def failed-task (task/failed (RuntimeException. "argf")))
</code></pre>
<p>To get the exception that caused the failure, use <a href="task.core.html#var-failure">failure</a>:</p>
<pre><code class="clojure">(task/failure failed-task) ; =&gt; RuntimeException[:cause "argf"] 
</code></pre>
<p>To force a task to fail, like <a href="task.core.html#var-force.21">force!</a>, use <a href="task.core.html#var-fail.21">fail!</a>:</p>
<pre><code class="clojure">(def foo (task/now "hi there"))

(task/fail! foo (IllegalStateException. "poop"))

(task/failed? foo) ; =&gt; true

(task/failure foo) ; =&gt; IllegalStateException[:cause "poop"]
</code></pre>
<p>Chaining a failed task to a normal task will cause the resulting task to fail.</p>
<h1><a href="#recovering-from-errors" name="recovering-from-errors"></a>Recovering from errors</h1>
<p>To recover from errors, use <a href="task.core.html#var-recover">recover</a>:</p>
<pre><code class="clojure">(def boom (task/run (/ 1 0)))

(def incremented (task/then inc boom))
</code></pre>
<p>This will blow up, so we can ensure that the resulting operation succeeds:</p>
<pre><code class="clojure">@(recover incremented
          (fn [ex]
            (println "caught exception: " (.getMessage ex))
            123))

; caught exception: java.lang.ArithmeticException: Divide by zero
; =&gt; 123
</code></pre>
<p>So you can recover from potential failures using a backup value from the function. Supplying a non-function will just recover with that value:</p>
<pre><code class="clojure">@(recover boom "hello") ; =&gt; "hello"
</code></pre></div></div></div></body></html>